val sc =
	(
		(0.0, 0.0, 0.0),
		(
			(0.3, 0.3, 0.3),
			[
				(
					(~1.0, 1.5, 2.0),
					(0.75, 0.3, 1.0),
					70.0
				),
				(
					(2.0, 1.5, 2.0),
					(0.3, 1.0, 0.75),
					100.0
				),
				(
					(0.0, 2.0, 0.0),
					(1.0, 1.0, 1.0), 
					35.0
				),
				(
					(~2.0, 2.0, 0.0),
					(1.0, 1.0, 1.0),
					50.0
				)
			]
		),
		[
			(
				Shape.Sphere((0.0, 0.1, ~0.5), 0.5),
				let
					fun gradient x =
						if x < 0.0 then
							gradient Vector3.EPSILON
						else if x < 0.2 then
							(1.0, x * 5.0, 0.0)
						else if x < 0.4 then
							(2.0 - x * 5.0, 1.0, 0.0)
						else if x < 0.6 then
							(0.0, 1.0, x * 5.0 - 2.0)
						else if x < 0.8 then
							(0.0, 4.0 - x * 5.0, 1.0)
						else if x <= 1.0 then
							(x * 5.0 - 4.0, 0.0, 1.0)
						else
							gradient (1.0 - Vector3.EPSILON)
				in
					fn (x, y, z) => (gradient (y + 0.4), 1.0, 0.8, 1.0, 3.0, 0.15)
				end
			),
			(
				Shape.Constrained(
					Shape.Sphere((~0.75, ~0.15, ~0.5), 0.15),
					fn (x, y, z) => (x + 0.75) >= (z + 0.5)
				),
				fn (x, y, z) => ((0.0, 1.0, 0.0), 1.0, 0.9, 1.0, 7.0, 0.15)
			),
			(
				Shape.Constrained(
					Shape.Sphere((0.75, ~0.15, ~0.5), 0.15),
					fn (x, y, z) => (x - 0.75) <= ~(z + 0.5)
				),
				fn (x, y, z) => ((0.0, 0.0, 1.0), 1.0, 0.9, 1.0, 7.0, 0.15)
			),
			(
				Shape.Sphere((0.0, ~0.15, 0.25), 0.15),
				fn (x, y, z) => ((1.0, 0.0, 0.0), 1.0, 0.4, 1.0, 5.0, 0.15)
			),
			(
				Shape.Plane(Plane.fromNormalAndPoint((0.0, 1.0, 0.0), (0.0, ~0.4, 0.0))),
				fn (x, y, z) => ((1.0, 1.0, 1.0), 0.3, 0.7, 0.0, 0.0, 0.03)
			),
			(
				Shape.Triangle(
					(~2.0, 0.5, ~2.0),
					(~2.0, 1.75, ~1.5),
					(2.0, 0.5, ~2.0)
				),
				fn (x, y, z) => ((1.0, 0.75, 0.75), 5.0, 0.0, 0.0, 1.0, 0.8)
			),
			(
				Shape.Triangle(
					(~2.0, 1.75, ~1.5),
					(2.0, 1.75, ~1.5),
					(2.0, 0.5, ~2.0)
				),
				fn (x, y, z) => ((0.75, 0.75, 1.0), 5.0, 0.0, 0.0, 1.0, 0.8)
			),
			(
				Shape.Triangle(
					(1.5, ~0.4, ~1.0),
					(0.0, ~0.4, 1.0),
					(~1.5, ~0.4, ~1.0)
				),
				fn (x, y, z) => ((1.0, 1.0, 1.0), 0.0, 0.0, 0.0, 1.0, 1.0)
			),
			(
				Shape.Torus(
					(0.0, 0.1, ~0.5),
					(1.0, 0.0, 1.0),
					0.7, 0.1
				),
				fn (x, y, z) => ((1.0, 1.0, 0.0), 1.0, 0.8, 0.4, 10.0, 0.15)
			),
			(
				Shape.Torus(
					(0.0, 0.1, ~0.5),
					(1.0, 0.0, ~1.0),
					0.7, 0.1
				),
				fn (x, y, z) => ((1.0, 0.0, 1.0), 1.0, 0.8, 0.4, 10.0, 0.15)
			),
			(
				Shape.Cone(
					Line.fromPosAndDir(
						(~2.0, 1.75, ~1.5),
						(0.35, ~1.0, 0.75)
					),
					Math.pi / 24.0,
					0.0, 3.5
				),
				fn (x, y, z) => (((y + 0.4) / 2.15, 1.0 - (y + 0.4) / 2.15, 1.0), 1.0, 0.8, 0.8, 6.0, 0.2)
			),
			(
				Shape.Constrained(
					Shape.InfCylinder(
						Line.fromPosAndDir(
							(2.0, 1.5, ~1.5),
							(~0.35, ~1.0, 0.75)
						),
						0.25
					),
					fn (x, y, z) => z >= ~1.5 andalso z <= ~0.5
				),
				fn (x, y, z) => (((y + 0.4) / 2.15, 1.0 - (y + 0.4) / 2.15, 1.0), 1.0, 0.8, 0.8, 6.0, 0.2)
			)
		]
	) : Scene.scene;

val cam =
	(
		(0.0, 2.85, 11.0),
		(0.0, ~0.2, ~1.0),
		(0.0, 1.0, 0.0),
		25.0 * Math.pi / 180.0
	) : Renderer.camera

val img = Image.createImage (640, 360) (0, 0, 0);

Renderer.render (cam, sc, 5) img;

Image.toBinPPM img "img.ppm";